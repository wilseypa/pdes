
#header<<

// See copyright notice in file Copyright in the root directory of this archive.

#include "ConfigurationScope.h"
#include "ConfigurationValue.h"
#include "ConfigurationChoice.h"
#include <vector>
#include <stdio.h>
#include "Debug.h"
>>


<<
// Base info for DLG-generated scanner
#include "DLexerBase.h"

// The scanner generated by DLG from this file
#include "ConfigurationLexer.h"

// Base token definitions for ANTLR
#include "AToken.h"

// Define your token type (ANTLRToken) as just ANTLRCommonToken
// (basically just token type and text
typedef ANTLRCommonToken ANTLRToken;

const ConfigurationScope *
WarpedConfigurationParser::parseFile( string fileName ){
  const ConfigurationScope *outerScope = 0;

  // define input file; standard input for this one
  const char *filename = fileName.c_str();
  FILE *inputFile = fopen( filename, "r" );

  if( inputFile != 0 ){
    DLGFileInput in( inputFile );
    
    // define an instance of your scanner
    ConfigurationLexer scanner(&in);
    
    // define token buffer between scanner and parser
    ANTLRTokenBuffer pipe(&scanner);
    
    // create a token to use as a model
    ANTLRToken tok;
    
    // tell the scanner what type the token is
    scanner.setToken(&tok);
    
    // create an instance of your parser
    WarpedConfigurationParser myParser(&pipe);
    
    // initialize your parser
    myParser.init();
  
    // start first rule
    outerScope = myParser.warpedConfigurationFile();
    if( outerScope != 0 &&
	outerScope->findChoice("DEBUG") != 0 &&
	outerScope->findStringChoice("DEBUG") == "TRUE" ){
      debug.enable();
    }
  }
  else{
    string error = "Error reading configuration file \"" + fileName + "\"";
    perror( error.c_str() );
  }

  return outerScope; 
}
>>

#lexclass START

// Whitespace start

#token "\ " <<skip();>>
#token "\t" <<skip();>>
#token "\r" <<skip(); newline();>>
#token "\n" <<skip(); newline();>>

// Allow bash comments
#token "# ~[\n@]* [\n@]" <<skip(); newline();>>

// Here are the meaningful tokens

#token IDENTIFIER("identifier") "[a-zA-Z]*"
#token INTEGERVAL("integer") "[0-9][0-9]*"
#token FLOATVAL("float") "[0-9][0-9]*.[0-9][0-9]*"
#token COMMA(",") ","
#token COLON(":") ":"
#token LBRACE("{") "\{"
#token RBRACE("}") "\}"
#token END("EOF") "@"

class WarpedConfigurationParser {
<<
public:
  void init(){
    ANTLRParser::init();
  }

  static const ConfigurationScope *
  WarpedConfigurationParser::parseFile( string fileName );
>>

warpedConfigurationFile > [ const ConfigurationScope *outerScope ]:
  <<
  ConfigurationScope *retval = new ConfigurationScope( "" );
  >>
  nested_configuration[ retval ]
  END
  <<
    $outerScope = retval;
  >>
;

nested_configuration[ ConfigurationScope *outerScope ]:
  ((IDENTIFIER COLON)?config_value[outerScope]
   | configuration_scope[outerScope])*
;

configuration_scope[ ConfigurationScope *outerScope ]:
  <<
    ConfigurationScope *newScope = 0;
  >>
  id:IDENTIFIER
  <<
    newScope = new ConfigurationScope( id->getText() );
    outerScope->addScope( newScope );
  >>
  LBRACE
  nested_configuration[ newScope ]
  RBRACE
;

config_value[ ConfigurationScope *outerScope ]:
  <<
    ConfigurationValue *firstValue = 0;
    ConfigurationValue *nextValue = 0;
    ConfigurationChoice *newChoice = 0;
    vector<const ConfigurationValue *> *myVector = 0;
  >>
  id:IDENTIFIER COLON
  <<
    newChoice = new ConfigurationChoice( id->getText() );
  >>
  value > [ firstValue ]
  { 
    (COMMA
     value > [ nextValue ]
     <<
      if( myVector == 0 ){
        myVector = new vector<const ConfigurationValue *>;
        myVector->push_back( firstValue );
      }
      myVector->push_back( nextValue );
    >>
    )*
  }
  <<
    if( myVector == 0 ){
      newChoice->setConfigurationValue( firstValue );
    }
    else{
      newChoice->setConfigurationValue( new VectorConfigurationValue( myVector ) );
    }
    outerScope->addChoice( newChoice );
  >>
;

value > [ConfigurationValue *retval]:
  <<
    $retval = 0;
  >>
  (
    id:IDENTIFIER
    <<
      $retval = new StringConfigurationValue( id->getText() );
    >>
    |
    inttok:INTEGERVAL
    <<
      $retval = new IntConfigurationValue( inttok->getText() );
    >>
    |
    floattok:FLOATVAL
    <<
      $retval = new FloatConfigurationValue( floattok->getText() );
    >>
  )
;
